[0.2]
This release adds already big parts of the soccer specific parts to the 
simulator. All soccer specific things are realized as plugins to the 
simulator, they are located in the soccer bundle in plugin/soccer/.

- rcssmonitor3D and soccer simulation:
  Starting with our simple monitor: here are the most visible changes.
  You can see a soccer field with two goals, a ball and agents in different
  colors dependend on the side they are playing on. 
  You can use keys 'a', 's,', 'd', and 'w' to move the camera (as was as 
  the mouse). The monitor can send simple commands to the simulator now.
  ('k' is of kick off, that is what you probably wanted to know).
  The soccer field is a standard FIFA size field with variable size, same with
  the ball and goals.
- Soccer Plugins
  Here is the really big part of the changes. Agents have an (omni-)drive and 
  a kicker now, they can perceive the environment with a kind of 360° omnicam
  and they get updates about the game state and things like the battery state.
  Using the omnidrive, agents can do 100m in something about 13s or 14s.

On startup, the simulator will start two different types of agents now. Even 
though there are only a few soccer rules implemented, it should be possible
to implement a simple soccer team. To facilitate programming a new team, we 
enhanced the sample client a bit. 

Finally, we added a small text (lacking a comprehensive manual),
describing the basic features of the simulated robots in the simulation. 

[0.1]
This is the initial release of rcssserver3D. To get an idea of what
rcssserver3D provides in general, please see also the file README.

- liboxygen / libkerosin
  libkerosin, the library containing the big part of the simulation
  system has been split up. We have now liboxygen containing the
  pure simulator part, and libkerosin containing the graphical output,
  user input and stuff like this. Because of issues with different
  OpenGL drivers, libkerosin is currently not used for graphical
  output. Another advantage of the split into liboxygen and libkerosin
  is that we can have a standalone simulator with no graphics.
  By default, libkerosin will not be build (if you want to build it
   anyway: libkerosin needs a few other libaries. See the
   documentation for details).

- SPADES integration
  For handling agents as external processes, we integrated SPADES into
  the simulator. SPADES is a middleware system for agent-based
  distributed simulation and was introduced by Patrick Riley on the 
  RoboCup 2002 symposium. Among other things, the simulator gets a
  model of simulation time and support for external monitors by using
  SPADES.  

- GameControlServer
  We added a GameControlServer as central instance for keeping
  information and classes relevant to agents in a simulation. An
  important part of the GameControlServer is a reference to a 
  parser responsible for parsing messages from agents into an internal
  representation. Parsers can be plugged in into the
  GameControlServer, so the simulator does not depend on a fixed
  protocol. Parsers are also responsible for generating messages from
  the internal representation.

- S-Expressions parser
  As a specific instance of a pluggable parser, we implemented a
  parser for parsing and generating S-Expressions (lists as used in 
  functional programming languages like LISP or Scheme). We also
  discussed using XML as protocol between agents and simulator. There
  was no clear joint position for or against XML or
  S-Expressions. There is no XML parser module now because noone
  implemented it :)

- CreateEffector
  We added a CreateEffector. The idea behind the CreateEffector is
  that once the agents connected to the simulator, they do not have a
  physical representation, other effectors or perceptors yet. By using
  the CreateEffector, agents can request specific effectors,
  perceptors, and bodies. Right now, the create effector requests a
  default agent with a perfect vision sensor, a simple force effector,
  an InitEffector for changing the team name, and a sphere like body.

- simple external monitor
  To get an impression of what actually happens we implemented a
  simple external monitor based on simple OpenGL stuff (it does not
  use our libkerosin library). The external monitor also uses
  sexpressions as syntax. The protocol is even more preliminary 
  than the agent protocol...

- a simple external SPADES agent
  We also implemented a very simple agent as sample implementation for
  external agents. The sample agent does (almost) nothing.

- ...

[Demo]

Physical Simulator as shown on RoboCup 2003 symposium
=====================================================
- libzeitgeist
  A class object system as core of the simulation system. A class
  object is just a factory of class instances. In addition to this
  mechanism, it also implements an object hierarchy. This hierarchy is
  essentially a virtual file system, where the 'directories' and
  'files' are instances of C++ classes. These two concepts are quite
  intertwined with each other, as class objects can also live inside
  the object hierarchy. Objects within the hierarchy are identified
  with a unique name. Class objects can also be loaded as plugins
  (loadable modules).

- libkerosin
  A physical simulator for simulation of rigid body dynamics based on
  ODE. We created a library that contains the big part of the
  simulator including visualization, physics, geometry, agents. We can
  also handle user input and playing sounds. The simulator library
  build upon the class object system mentioned above.

- demo
  A demo application with some spheres as agents. Agents try to get
  some food. The agents are part of the simulator loop; a simulation
  step is over if all agents finished thinking. Because of this, agents
  have infinite thinking time (in priciple). There is no model of time.

