 \chapter{System Overview}

%Briefly introduce the system and its components. Later chapters go into more detail.

SimSpark is built upon an application framework called zeitgeist. This
framework provides basic OS abstractions like file and archive
support, logging, shared libraries etc.), a scripting interface to
Ruby and a powerful plugin mechanism coupled with an object hierary
that provides a unified namespace. This library is the backbone of the
system.

Zeitgeist allows us to load new classes at runtime from plugins and
install object instances in a hierarchy. We can locate these instances
via path expression just like files in a file system. At various well
known locations are objects called servers that provide services to
other parts of the system. The script server that provides an
interface to the Ruby ist installed at \texttt{/sys/server/script}.

Built as part of this object hierarchy is a scene graph that the
system uses to represent the simulated world. This scene graph and
related concepts are managed within the next layer of the system, that
we call oxygen. It provides classes that encapsulate concepts like
transformations, basic geometric primitives, physical bodies and
collision primitives. It further provides access to a rigid body
physical simulation.

The oxygen library further implements basic simulation services like
agent management and a monitor framework. It is responsible to keep
track and to update connected agents and monitor processes. Last but
not least it provides a customizable run loop service. This service is
implemented as an abstract run loop that is extended with plugins as
needed. In parts of the system can be replaced or left out easily as
for example rendering or monitor support.

The Visualization of the scene and input event processing services are
provided by the kerosin library. It implements the infrastructure for
rendering and device management. Concrete implementations are again
provided by plugins. This allows the simulation to use different back
ends or graphic engine. A default set of plugins utilizes plain OpenGL
and the SDL library.

\section{The Server}

%Describe what the server does: physics, agent management, world modeling, ...

%scene graph, object aspects (physical, geometric, visual) 
%at simulation start physics simulation is setup from scene graph state

%running the simulation means 
% - collecting and applying forces (from agents, or game rule aspects) 
% - stepping the physics simulation and synchronizing the scene graph

%agent management 
%(connect/disconnect, sense, act
% sense reads from the scene 
% act modifies the scene (e.g applies forces)

%(optional) monitor management 
%(connect/disconnect, monitor update)
% pluggable server side monitor implementation; 
% scene specific protocols ; useful for every simulation; only concerned with scene
% simulation specific protocol addons; generate list of name/value pairs (predicates); transfer games state

%(optional) rendering
%no network overhead between server/monitor
%useful if on same machine, debugging purposes

%run loop
%is customized to update the different active server parts in a correct order

\section{The Monitor and Logplayer}

%Generic monitor that displays only scene
% customized with plugins
% plugins parse game specific data
% plugins render scene overly to display game state
% (internal version is described in server section)
% log playing

\section{The Sample Client}

%Demo client, demonstrates interaction with the server, how to read perceptor values, how to send effector values, can load different behaviors

%Provide links to a reositoriy of clients / papers from previous competitions?

\section{Available Simulations}

% soccer in previous version (spheres and articulated robots)

\section{Available Robot Models}

%NEC Papero Roboter  Joschka
%Fabio Della Libera models the VStone VisiON 4g
%CITIZEN Eco-B!
%HOAP-2
%'Vierbeiner' von Oli
%Aibo via RosImporter ;)

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "user-manual"
%%% End: 
