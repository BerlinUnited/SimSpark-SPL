
\chapter{Working with CVS}

\section{About CVS}

CVS (Concurrent Versions System) is a tool used by many software developers to manage 
changes within their source code tree. CVS provides the means to store not only the current 
version of a piece of source code, but a record of all changes (and who made those changes) 
that have occurred to that source code. Use of CVS is particularly common on projects with 
multiple developers, since CVS ensures changes made by one developer are not accidentally 
removed when another developer posts their changes to the source tree.

Information about accessing this CVS repository may be found in our document titled, 
"Basic Introduction to CVS and SourceForge.net (SF.net) Project CVS Services".

In order to access a CVS repository, you must install a special piece of software called a 
CVS client; CVS clients are available for most any operating system. 
Information about CVS client software may be found in our document titled, 
"Basic Introduction to CVS and SourceForge.net (SF.net) Project CVS Services".

\section{Access to CVS}

\subsection{Anonymous CVS Access}
This project's SourceForge.net CVS repository can be checked out through anonymous (pserver) 
CVS with the following instruction set. The module you wish to check out must be specified as 
the modulename. When prompted for a password for anonymous, simply press the Enter key. 
To determine the names of the modules created by this project, you may examine their CVS 
repository via the provided web-based CVS repository viewer.

\begin{verbatim}
cvs -d:pserver:anonymous@cvs.sourceforge.net:/cvsroot/sserver login
cvs -z3 -d:pserver:anonymous@cvs.sourceforge.net:/cvsroot/sserver co modulename
\end{verbatim}

Information about accessing this CVS repository may be found in our document titled, 
"Basic Introduction to CVS and SourceForge.net (SF.net) Project CVS Services".

Updates from within the module's directory do not need the -d parameter.

NOTE: UNIX file and directory names are case sensitive. 
The path to the project CVSROOT must be specified using lowercase characters (i.e. /cvsroot/sserver)


\subsection{Developer CVS Access via SSH}

Only project developers can access the CVS tree via this method. 
A SSH client must be installed on your client machine. Substitute modulename 
and developername with the proper values. Enter your site password when prompted.

A significant amount of information about project CVS services may be found in our 
"Introduction to Project CVS Services". Developers new to CVS should read our 
"Basic Introduction to CVS and SourceForge.net (SF.net) Project CVS Services".

Developers may also make use of shared SSH keys for authentication.

\begin{verbatim}
export CVS_RSH=ssh
cvs -z3 -d:ext:developername@cvs.sourceforge.net:/cvsroot/sserver co modulename
\end{verbatim}

NOTE: UNIX file and directory names are case sensitive. 
The path to the project CVSROOT must be specified using lowercase characters (i.e. /cvsroot/sserver)

\subsection{Accessing a Branch}
You can retrieve a branch in one of two ways: by checking it out fresh from the repository, or by switching an existing working copy over to the branch.

To check out a branch from the repository, invoke checkout with the -r flag, followed by the tag name of the branch (i.e. rel-1-0-patches, module: tc):

\begin{verbatim}
$ cvs checkout -r rel-1-0-patches tc
\end{verbatim}

Or, if you already have a working copy, you can switch it to a given branch with update -r:

\begin{verbatim}
$ cvs update -r rel-1-0-patches tc
\end{verbatim}

or equivalently:

\begin{verbatim}
$ cd tc
$ cvs update -r rel-1-0-patches
\end{verbatim}

It does not matter if the working copy was originally on the main trunk or on some other branch - the above command will switch it to the named branch.  And similarly to a regular update command, update -r merges any changes you have made, notifying you of conflicts where they occur.

Once you have a working copy tied to a particular branch, it remains there until you tell it otherwise.  This means that changes checked in from the working copy will add new revisions on that branch, while leaving the main trunk and other branches unaffected.



\section{Writing to CVS}

\subsection{Checking in a File}

The commit command sends modifications to the repository. If you don't name any files, a commit will send all changes to the repository; otherwise, you can pass the names of one or more files to be committed (other files would be ignored, in that case). 

Here, we commit one file by name and two by inference: 

\begin{verbatim}
$ cvs commit -m "print goodbye too" hello.c
Checking in hello.c;
/usr/local/cvs/myproj/hello.c,v  <--  hello.c
new revision: 1.2; previous revision: 1.1
done
$ cvs commit -m "filled out C code"
cvs commit: Examining .
cvs commit: Examining a-subdir
cvs commit: Examining a-subdir/subsubdir
cvs commit: Examining b-subdir
Checking in a-subdir/subsubdir/fish.c;
/usr/local/cvs/myproj/a-subdir/subsubdir/fish.c,v  <--  fish.c
new revision: 1.2; previous revision: 1.1
done
Checking in b-subdir/random.c;
/usr/local/cvs/myproj/b-subdir/random.c,v  <--  random.c
new revision: 1.2; previous revision: 1.1
done
$
\end{verbatim}

Take a moment to read over the output carefully. Most of what it says is pretty self-explanatory. One thing you may notice is that revision numbers have been incremented (as expected), but the original revisions are listed as 1.1 instead of 1.1.1.1. 

There is an explanation for this discrepancy, but it's not very important. It concerns a special meaning that CVS attaches to revision 1.1.1.1. For most purposes, we can just say that files receive a revision number of 1.1 when imported, but the number is displayed as 1.1.1.1 in the Entries file, until the first commit.


\subsection{Checking in from a Branch}

You can commit to a branch revision with the `-r' option. Then, either checkout or update can be used to base your sources on the newly created branch. From that point on, all commit changes made within these working sources will be automatically added to a branch revision, thereby not disturbing main-line development in any way. For example, if you had to create a patch to the 1.2 version of the product, even though the 2.0 version is already under development, you might do: 

\begin{verbatim}
$ cvs rtag -b -r FCS1_2 FCS1_2_Patch product_module
$ cvs checkout -r FCS1_2_Patch product_module
$ cd product_module
[[ hack away ]]
$ cvs commit
\end{verbatim}

This works automatically since the `-r' option is sticky.


\subsection{Creating Tags}

Tagging affects the repository, not the working copy. That begs the question: Why require a working copy at all when tagging? The only purpose that it serves is to designate which project and which revisions of the various files in the project are being tagged. If you could specify the project and revisions independently of the working copy, no working copy would be necessary.

There is such a way: the rtag command (for "repository tag"). It's very similar to tag; a couple of examples will explain its usage. Let's go back to the moment when the first bug report came in and we needed to create a branch rooted at the last public release. We checked out a working copy at the release tag and then ran tag -b on it: 

\begin{verbatim}
$ cvs tag -b Release-1999_05_01-bugfixes
\end{verbatim}

This created a branch rooted at Release-1999\_05\_01. However, because we know the release tag, we could have used it in an rtag command to specify where to root the branch, not even bothering with a working copy: 

\begin{verbatim}
$ cvs rtag -b -r Release-1999_05_01 Release-1999_05_01-bugfixes myproj
\end{verbatim}

That's all there is to it. That command can be issued from anywhere, inside or outside a working copy. However, your CVSROOT environment variable would have to point to the repository, of course, or you can specify it with the global -d option. It works for non-branch tagging, too, but it's less useful that way because you have to specify each file's revision number, one by one. (Or you can refer to it by tag, but then you'd obviously already have a tag there, so why would you want to set a second one on the exact same revisions?) 