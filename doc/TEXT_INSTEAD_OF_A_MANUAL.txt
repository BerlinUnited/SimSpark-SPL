TEXT_INSTEAD_OF_A_MANUAL.txt

rcssserver3D provides a platform for programming simulated robots
playing soccer in a physical environment.


Contents
--------

1. System Overview
2. Soccer Simulation
3. Monitor and Trainer Protocol
4. References


1. System Overview
------------------

To get started you should be somewhat familiar with the components of
the system. The soccer simulation consists of three important parts:
the server, the monitor and the agents.

In order to work with the server you should be familiar with the
SPADES [1] simulation middleware. Some important concepts you should
know about: The server is responsible to start an agent process,
i.e. it does not wait for an agent to connect. The SPADES library uses
a database that contains information how to start different agent
types. It is called 'agentdb.xml' (see ./app/simulator/
directory). Agents connect using UNIX pipes to a SPADES ComServer
using a length prefixed format to exchange messages with the
server. Please see the SPADES manual for further details.

The default monitor is called rcssmonitor3D-lite it is located in the
./app/rcssmonitor3d/lite directory. It is also used to replay logfiles
that the server automatically creates (use the --logfile <filename>
option). The automatically generated logfile is called
'monitor.log'. You'll find it in the 'Logfiles/' directory below the
directory in which you started the server.

The implemented monitor protocol supports a command set to implement a
trainer, i.e to automatically recreate test situations on the field
and to evaluate an agents behavior. A 'monitor library' is provided
to help implementing custom monitor and trainer applications, please
see the ./app/rcssmonitor3d/lib directory. The protocol between server
and monitor is detailed further down in this text file.

A good starting point for your own agent implementations is the
'agenttest' program in the ./app/agenttest/ directory. This agent
implements a simple kick and run behavior.

Because there is no manual for the simulator, this text tries to
describe the features of the simulated robots.

2. Soccer Simulation
--------------------

Your soccer team consists of a number of robots with equal
capabilities. The programs you should write to create a team exchange
data with the (virtual) low level control system delivered with the
robots. Both perceptors and effectors of your robots work with
S-expressions, this is the syntax you know already from the 2D soccer
simulator, or maybe also from your favourite programming language :). 

Some technical data of the environment and of your new robots:

The playing field is a plane with FIFA standard soccer field
size (length between 100m and 110m, width between 64m and 75m).
Goal boxes and the ball are also standard FIFA size:
goals are 7.32m wide; the ball has got a diameter of
0.222m and weighs between 0.41kg and 0.45kg. 
Because our agents are small and cannot jump, goals are only 0.5m 
high -- the official FIFA height is 2.44m.

FIFA does not say too much about gravity (probably because they can't
change it anyway), but in our simulation, gravity is fixed to
9.81m/s². 

In the current version of the simulator, robots are represented as
spheres (until we can come up with a more sophisticated representation
next year). The diameter of all robots is 0.44m, and each robots
weighs 75kg. 

Robots possess a kind of omnidrive, which adds some physical force to
the robot body. By using the omnidrive, it is possible to accelerate
into any direction, and it is also possible to jump very
little. However, the omnidrive does only work if the robot is actually
touching the soccer field. If you stop accelerating, robots will still
move for a while, and you also cannot suddenly stop when moving with
full speed (but you can use it for breaking). The maximum speed and
the maximum height for jumping up if yet to be discovered. To use the
omnidrive, you have to use the "driveeffector", which takes a
cartesian vector (x y z) with a maximum length of 100 units. The
x-coordinate points towards the opponents team side of the field, z
points up. With the driveeffector, you set a kind of motor force,
i.e. if you want to drive full speed for a while, it is sufficient to
use the driveeffector *once*. The force you set is applied at each
simulator step until you change it again (btw simulator steps are
0.01s long). The driveeffector works realiable, there is a small error
for forces along each axis (each up to 2% of the applied force). The
error is normally distributed around 0.0.

Using the omnidrive consumes battery. You get to know of battery states 
by reading the agentstateperceptor. If the battery is empty, the omnidrive
will stop working.

It is also possible to push away other robots. Using this feature to
push away opponents is discouraged :). 

Example command: (drive 20.0 50.0 0.0)


To move the ball, you have the option of simply using the robots to
push the ball into a desired direction, or you can use the
kickeffector to kick the ball.  

  (Originally, we did not intend to create an artificial
   kickeffector. However, to make use of the 3rd dimension, this was
   the easiest way. It is intended to remove this kind of kick
   effector in future versions (not this years' competition) in favour
   of a real physical device).

The kickeffector can accelerate the ball radially away from the robot
body. The kickeffector takes an angle as first argument (this is the
latitudal angle (in degrees) for accelerating the ball, a number
between 0 and 50). The second argument indicates the kicking power and
this is a number between 0 and 100 (meaning % of the maximum available
power). The kickeffector adds a force and a torque to the ball (over a
fixed number of simulation steps, currently 10 (i.e. 1/10s with the 
current settings).
To kick the ball, the ball has to be very close to the robot (0.04m). 

The kickeffector noise has the following parameters:
- angle error in the x-y plane: very low
  normally distributed around 0.0 (sigma = 0.02)
- latitudal angle error: normally distributed around 0.0.
  this angle error is low (sigma = 0.9) at the end positions 
  (at 0 and at 50 degrees), towards the middle of the range the angle
  error is higher (with sigma up to 4.5).
- kick power error: normally distributed around 0.0, sigma = 0.4

You cannot change the kicking angle in the x-y plane, i.e. you have to
move the robot so that it can kick into the desired direction.
Right now, the kickeffector is not very strong, because something like an 
offside rule is missing. It should also not be possible to move other robots by
kicking the ball against them anymore. (at least not very much :)
Like the driveeffector, the kickeffector does only work if the robot
touches the soccer field. 

Example command: (kick 20.0 80.0)


At startup, you have to do two things: 
1) create the robot you want to use
2) initialize the robot with a teamname

1) When you at first connect to the simulator, your agent does not have any 
physical representation. The only thing your agent has got is a "createeffector". 
The idea of the createeffector is that you can request different effectors,
perceptors or robot types. Currently, there is only one fixed robot type, so the
createefector ignores all parameters. For now, you should simply do "(create)" 
at the beginning and you will get the default robot type.

2) To set the teamname and uniform number, you have to use the initeffector. 
Prior to initializing, your effectors and perceptors will not work properly.
Example: "(init (unum 7) (teamname RoboLog))".  


"Beaming" agents: the beameffector
Similar to the kickeffector, the initial plan was not to introduce any artificial 
actions like "beaming" agents from one place to another place ("move"
command in 2d soccer server). Still, the plan is to develop the soccer
simulation so that beaming can disappear from the set of
effectors. However the problem was that due to limited time we had to
do something about moving agents to their half in before kick off
mode. To remove "beaming", the referee has to be extended to send
yellow or red cards to players that don't behave properly... with your
help :) we are going to work on this feature in the near future. Until
then, beaming of agents is allowed in beforekickoff mode.



Vision: Your robots possess a special omnicam with some smart image
proccessing software attached :). Robots have a 360 degrees view. The
visionperceptor delivers lists of seen objects, where objects are
either others robots, the ball, or markers on the field (there are
currently 8 markers on the field: 4 flags and 4 goal posts). With each
object you get its distance, the angle in the x-y plane (0 degrees
into direction of the opponent half) and the latitudal angle 
(0 degrees means horizontally). Contrary to 2D soccer simulation, the 
vision system does not deliver object velocities. Objects can be
occluded by other objects (this is not implemented yet). All distances
and angles are given relative to the camera position (currently at the
center of the robot sphere).

The noise parameters of the vision system are as follows:
- calibration error: 
  A small error is added to the camera position. For each axis, the
  error is uniformly distributed between -0.005m and 0.005m. The error
  is calculated once and remains constant during the complete match.
- noise: all errors normally distributed around 0.0
  + distance error:  sigma = 0.0965
  + angle error (x-y plane): sigma = 0.1225
  + angle error (latitudal): sigma = 0.1480

Example Vision output: 
(Vision (Flag (id 1_l) (pol 54.3137 -148.083 -0.152227)) (Flag (id
2_l) (pol 59.4273 141.046 -0.131907)) (Flag (id 1_r) (pol 61.9718
-27.4136 -0.123048)) (Flag (id 2_r) (pol 66.4986 34.3644 -0.108964))
(Goal (id 1_l) (pol 46.1688 179.18 -0.193898)) (Goal (id 2_l) (pol
46.8624 170.182 -0.189786)) (Goal (id 1_r) (pol 54.9749 0.874504
-0.149385)) (Goal (id 2_r) (pol 55.5585 8.45381 -0.146933)) (Ball (pol
6.2928 45.0858 -0.94987)) (Player (team robolog) (id 1) (pol 7.33643
37.5782 5.86774)))


The GameStatePerceptor tells you about the current status of the game. The first percept
you get from this perceptor tells you about some of the game variables 
(like ball weight and field size etc) additionally.

The AgentStatePerceptor notifies you about internal states of the agent (currently 
only the battery state).

3. Monitor and Trainer Protocol
-------------------------------

The default monitor port for the soccer simulation is 12001. The
server periodically sends you lines of text that contain
S-Expressions.

The monitor log file, that contains the recorded sequence of all
expressions sent to the monitor is further used as the log file
format. It is automatically generated in Logfiles/monitor.log relative
to the server directory.

== INIT Expression ==

Initially one 'Init' expression is sent. An example init expression is
given below. Note that S-Expressions from the server are received as a
single line. Their are reformatted here for readability.

(Init 
      (FieldLength 104)(FieldWidth 68)(FieldHeight 40)
      (GoalWidth 7.32)(GoalDepth 2)(GoalHeight 0.5)(BorderSize 10)
      (FreeKickDistance 9.15)(WaitBeforeKickOff 2)(AgentMass 75)
      (AgentRadius 0.22)(AgentMaxSpeed 10)(BallRadius 0.111)
      (BallMass 0.425878)(RuleGoalPauseTime 3)(RuleKickInPauseTime 1)
      (RuleHalfTime 300)
      (play_modes BeforeKickOff KickOff_Left KickOff_Right PlayOn
      KickIn_Left KickIn_Right corner_kick_left corner_kick_right
      goal_kick_left goal_kick_right offside_left offside_right
      GameOver Goal_Left Goal_Right free_kick_left free_kick_right)
      )

Each subexpression of the init expression is a name value pair that
gives one parameter that the current instance of the simulation
uses. The meaning of the different parameters:

- FieldLength,FieldWidth,FieldHeight: dimensions of the soccer field
in meter

- GoalWidth, GoalDepth, GoalHeight: dimensions of the goals in meter

- BorderSize: the simulated soccer field is surrounded by an off field
area. BorderSize gives the extra space in meters relative to the
regular field dimensions in meters

- FreeKickDistance: gives the distance in meters that agents of the
opposite have to adhere when a player carries out a free kick.

- WaitBeforeKickOff: gives the time in seconds the server waits before automatically starting the game

- AgentMass: the mass of each agent in kg

- AgentRadius: the radius of each agent in m

- AgentMaxSpeed: the maximum speed of each agent in m/s

- BallRadius: the radius if the ball in m

- BallMass: the mass of the ball in kg

- RuleGoalPauseTime: the time in seconds that the server waits after a
goal is scored before switching to kick off playmode

- RuleKickInPauseTime: the time in seconds that the server waits after
the ball left the field before switching to the kick in playmode

- RuleHalfTime: the length of one half time in seconds

- play_modes: lists the the different play_modes of the soccer
simulation. Later on play_modes are referenced by a zero based index
into this list.

== INFO Expression == 

After the initial init message is sent only Info expressions are
sent. These expressions contain the full state of the current
simulation state. An example Info expression is given below:

(Info 
      (time 0)(half 1)(score_left 0)(score_right 0)(play_mode 0)
      (P (pos 0 0 0))(P (pos 0 0 0))(P (pos 0 0 0))(P (pos 0 0 0))
      (P (pos 0 0 0))(P (pos 0 0 0))(P (pos 0 0 0))(P (pos 0 0 0))
      (P (pos 0 0 0))(P (pos 0 0 0))(F (id 1_l)(pos -52 -34 0))
      (F (id 2_l)(pos -52 34 0))(F (id 1_r)(pos 52 -34 0))(F (id 2_r)(pos 52 34 0))
      (G (id 1_l)(pos -52 -3.66 0))(G (id 2_l)(pos -52 3.66 0))
      (G (id 1_r)(pos 52 -3.66 0))(G (id 2_r)(pos 52 3.66 0))
      (B (pos 0 0 10))
      )

Each subexpression of the info expression is a name value pair that
contains information about one aspect of the current simulation
state. Not all subexpressions are repeated. This concers the positions
of the field flags and the names of the two teams. This information is
only sent once. Further game state information like the score count,
and the current game state is only sent if it changed. The meaning of
the different expressions:

- Die: notifies the monitor that the soccer simulation is about to terminate

- time: the current simulation time in seconds

- half: the current game half, 0 means the first, 1 means the second game half

- score_left, score_right: the score count of the left and right team respectively

- team_left, team_right: gives the names of the left and right team
respectively; the information is only sent once as it remains static

- play_mode: the current play mode as 0 based index into the
play_modes list given in the init expression

- P: gives information about a player. This expression may contain
further subexpressions.
  - s: gives the team the player belongs to; 0 for the left, 1 for the
  right team
  - id: gives the uniform number of the player
  - pos: gives the position of the player as a three component vector
  - last: if this subexpression is present, the player was the last to
  touch the ball
  - say: this expression gives the string the player sent using the
  optional SayEffector

- F: gives information about a flag on the field. Information about a
flag is only sent once, as it remains static
  - pos: gives the position of the flag as a three component vector
  - id: gives the name of the flag

- B: gives information about the ball
  - pos: gives the position of the ball as a three component vector

- ack: acknowledges a command that is carried out by the server;
carries a user defined cooky string as parameter; see below for
further explanation

== Monitor Command Parser ==

A connected monitor can further send commands as S-Expressions to the
server using the monitor connection. These commands allow a connected
monitor to set the current playmode and to move players and the ball
to arbitrary positions on the field. This allows for the
implementation of trainer clients.

Supported expressions are:

(kickOff): start the soccer game, tossing a coin to select the team
that kicks off first

(playMode <play_mode>): set the current playmode. Possible playmodes
are given as strings in the play_modes expression of the init
expression the monitor receives when it connects. Example: (playMode
corner_kick_left).

(agent(team [R,L])(unum <uniform number>(pos <x,y,z>)(vel <vx,vy,vz))
: set the position and velocity of the given player on the
field. Example: (agent (team L)(unum 1)(pos -52.0 0.0 0.3)(vel 0.0 0.0 0.0))

(ball (pos <x,y,z>)): set the position of the ball on the
field. Example: (ball (pos 10,20,1))

(dropBall): Drop ball at its current position and move all players
away by the free kick radius.

(getAck <cooky string>): experimental feature, currently
disabled. Requests an (ack <cooky>) reply from the server. The server
will send the answer as soon as the command is carried out. This is
used to synchronize a trainer implementation wit the server. The
getAck expression is appended behind one of the above
commands. Example: ((kickOff)(getAck kicked_off))


4. References
-------------
[1] http://spades-sim.sourceforge.net/


END OF TEXT.


If you ever get close to a human
And human behaviour
Be ready to get confused
There's definitely, definitely, definitely no logic.

(Bjork, Human Behaviour)


"Duct tape is a lot like the Force... It has a dark side, it has a light
side, and it binds the galaxy together...."
	(unknown author)
