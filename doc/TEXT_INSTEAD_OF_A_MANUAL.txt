TEXT_INSTEAD_OF_A_MANUAL.txt

rcssserver3D provides a platform for programming simulated robots
playing soccer in a physical environment. To get started, you should
be somewhat familiar with the SPADES simulation middleware, thought it
is possible to start by experimenting with the 'agenttest' program in
the ./app/agenttest/ directory.

Because there is no manual for the simulator, this text tries to
describe the features of the simulated robots.

Your soccer team consists of a number of robots with equal
capabilities. The programs you should write to create a team exchange
data with the (virtual) low level control system delivered with the
robots. Both perceptors and effectors of your robots work with
S-expressions, this is the syntax you know already from the 2D soccer
simulator, or maybe also from your favourite programming language :). 

Some technical data of the environment and of your new robots:

The playing field is a plane with FIFA standard soccer field
size (length between 100m and 110m, width between 64m and 75m).
Goal boxes and the ball are also standard FIFA size:
goals are 7.32m wide; the ball has got a diameter of
0.222m and weighs between 0.41kg and 0.45kg. 
Because our agents are small and cannot jump, goals are only 0.5m 
high -- the official FIFA height is 2.44m.

FIFA does not say too much about gravity (probably because they can't
change it anyway), but in our simulation, gravity is fixed to
9.81m/s². 

In the current version of the simulator, robots are represented as
spheres (until we can come up with a more sophisticated representation
next year). The diameter of all robots is 0.44m, and each robots
weighs 75kg. 


Robots possess a kind of omnidrive, which adds some physical force to
the robot body. By using the omnidrive, it is possible to accelerate
into any direction, and it is also possible to jump very
little. However, the omnidrive does only work if the robot is actually
touching the soccer field. If you stop accelerating, robots will still
move for a while, and you also cannot suddenly stop when moving with
full speed (but you can use it for breaking). The maximum speed and
the maximum height for jumping up if yet to be discovered. To use the
omnidrive, you have to use the "driveeffector", which takes a
cartesian vector (x y z) with a maximum length of 100 units. The
x-coordinate points towards the opponents team side of the field, z
points up. With the driveeffector, you set a kind of motor force,
i.e. if you want to drive full speed for a while, it is sufficient to
use the driveeffector *once*. The force you set is applied at each
simulator step until you change it again (btw simulator steps are
0.01s long). The driveeffector works realiable, there is a small error
for forces along each axis (each up to 2% of the applied force). The
error is normally distributed around 0.0.

Using the omnidrive consumes battery. You get to know of battery states 
by reading the agentstateperceptor. If the battery is empty, the omnidrive
will stop working.

It is also possible to push away other robots. Using this feature to
push away opponents is discouraged :). 

Example command: (drive 20.0 50.0 0.0)


To move the ball, you have the option of simply using the robots to
push the ball into a desired direction, or you can use the
kickeffector to kick the ball.  

  (Originally, we did not intend to create an artificial
   kickeffector. However, to make use of the 3rd dimension, this was
   the easiest way. It is intended to remove this kind of kick
   effector in future versions (not this years' competition) in favour
   of a real physical device).

The kickeffector can accelerate the ball radially away from the robot
body. The kickeffector takes an angle as first argument (this is the
latitudal angle (in degrees) for accelerating the ball, a number
between 0 and 50). The second argument indicates the kicking power and
this is a number between 0 and 100 (meaning % of the maximum available
power). The kickeffector adds a force and a torque to the ball (over a
fixed number of simulation steps, currently 10 (i.e. 1/10s with the 
current settings).
To kick the ball, the ball has to be very close to the robot (0.04m). 

The kickeffector noise has the following parameters:
- angle error in the x-y plane: very low
  normally distributed around 0.0 (sigma = 0.02)
- latitudal angle error: normally distributed around 0.0.
  this angle error is low (sigma = 0.9) at the end positions 
  (at 0 and at 50 degrees), towards the middle of the range the angle
  error is higher (with sigma up to 4.5).
- kick power error: normally distributed around 0.0, sigma = 0.4

You cannot change the kicking angle in the x-y plane, i.e. you have to
move the robot so that it can kick into the desired direction.
Right now, the kickeffector is not very strong, because something like an 
offside rule is missing. It should also not be possible to move other robots by
kicking the ball against them anymore. (at least not very much :)
Like the driveeffector, the kickeffector does only work if the robot
touches the soccer field. 

Example command: (kick 20.0 80.0)


At startup, you have to do two things: 
1) create the robot you want to use
2) initialize the robot with a teamname

1) When you at first connect to the simulator, your agent does not have any 
physical representation. The only thing your agent has got is a "createeffector". 
The idea of the createeffector is that you can request different effectors,
perceptors or robot types. Currently, there is only one fixed robot type, so the
createefector ignores all parameters. For now, you should simply do "(create)" 
at the beginning and you will get the default robot type.

2) To set the teamname and uniform number, you have to use the initeffector. 
Prior to initializing, your effectors and perceptors will not work properly.
Example: "(init (unum 7) (teamname RoboLog))".  


"Beaming" agents: the beameffector
Similar to the kickeffector, the initial plan was not to introduce any artificial 
actions like "beaming" agents from one place to another place ("move"
command in 2d soccer server). Still, the plan is to develop the soccer
simulation so that beaming can disappear from the set of
effectors. However the problem was that due to limited time we had to
do something about moving agents to their half in before kick off
mode. To remove "beaming", the referee has to be extended to send
yellow or red cards to players that don't behave properly... with your
help :) we are going to work on this feature in the near future. Until
then, beaming of agents is allowed in beforekickoff mode.



Vision: Your robots possess a special omnicam with some smart image
proccessing software attached :). Robots have a 360 degrees view. The
visionperceptor delivers lists of seen objects, where objects are
either others robots, the ball, or markers on the field (there are
currently 8 markers on the field: 4 flags and 4 goal posts). With each
object you get its distance, the angle in the x-y plane (0 degrees
into direction of the opponent half) and the latitudal angle 
(0 degrees means horizontally). Contrary to 2D soccer simulation, the 
vision system does not deliver object velocities. Objects can be
occluded by other objects (this is not implemented yet). All distances
and angles are given relative to the camera position (currently at the
center of the robot sphere).

The noise parameters of the vision system are as follows:
- calibration error: 
  A small error is added to the camera position. For each axis, the
  error is uniformly distributed between -0.005m and 0.005m. The error
  is calculated once and remains constant during the complete match.
- noise: all errors normally distributed around 0.0
  + distance error:  sigma = 0.0965
  + angle error (x-y plane): sigma = 0.1225
  + angle error (latitudal): sigma = 0.1480

Example Vision output: 
(Vision (Flag (id 1_l) (pol 60.1403 34.5596 -0.328613)) (Flag (id 2_l) 
(pol 60.0956 -34.4602 -0.456952)) (Flag (id 1_r) (pol 64.2538 147.935 -0.359082)) 
(Flag (id 2_r) (pol 64.148 -148.223 -0.421845)) (Goal (id 1_l) 
(pol 49.8231 4.27208 -0.323971)) (Goal (id 2_l) (pol 49.5938 -4.14056 -0.529796)) 
(Goal (id 1_r) (pol 54.5179 176.296 -0.523109)) (Goal (id 2_r) 
(pol 54.6331 -175.957 -0.211688)) (Ball (pol 2.6942 -179.859 -6.07302)) 
(foo (id 1099) (pol 5.12495 -180.146 0.156113)) (bar (id 1100) 
(pol 9.98603 -179.868 -0.227677)) (bar (id 1101) 
(pol 15.0581 -179.983 -0.206302)))


The GameStatePerceptor tells you about the current status of the game. The first percept
you get from this perceptor tells you about some of the game variables 
(like ball weight and field size etc) additionally.

The AgentStatePerceptor notifies you about internal states of the agent (currently 
only the battery state).


END OF TEXT.


Attention all planets of the solar federation
We have assumed control.

(RUSH, 2112)
