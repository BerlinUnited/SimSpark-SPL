\section{Scene Description Language}
\label{sec:scene}
Spark provides access to the managed scene graph in several ways.
Besides the internal C++ interface and external access via Ruby script
language, an extensible mechanism for scene description languages is
implemented. This allows for both a procedural and a description-based
scene setup.

A scene is imported using one of any number of registered scene
importer plugins, each supporting a different scene description
language. 

\subsection{RubySceneGraph language}

Currently one S-expression-based importer is implemented. This
reference language is called \emph{RubySceneGraph}. It maps the scene
graph structure to the nesting of Lisp-like \texttt{s-expressions}.

An s-expression is a list of elements. Each element is either an
\texttt{atom} or is itself another \texttt{list} of atoms. An atom is
either a predefined keyword or a non empty string literal that has no
further syntactic structure. The syntax of s-expressions, notated
using EBNF is given in Listing~\ref{rsg:ebnf}.

%xleftmargin=1cm,xrightmargin=1cm
\lstset{captionpos=b,frame=none,%
  basicstyle=\small,breaklines=true}

\begin{lstlisting}[caption={EBNF notation of s-expressions}, label=rsg:ebnf]
character    -> "A" | ... | "Z" | "1" | ... | "9",
atom         -> character+
list         -> "(" s_expression* ")"
s_expression -> atom | list
\end{lstlisting}

%xleftmargin=1cm,xrightmargin=1cm
\lstset{language=lisp,language=lisp,captionpos=b,frame=none,%
  basicstyle=\small,commentstyle=\bf,breaklines=true}

On the semantic side the \emph{RubySceneGraph} interpreter recognizes
a set of special atoms. The first atom in each subexpression
determines its type. The set of keywords comprises four atoms that
allow the interpreter to distinguishes five different expression
types. 

\begin{itemize}
  
\item The \texttt{RubySceneGraph} expression is the header expression
  of every scene graph file.
\item The \texttt{node} expression declares a new scene graph node.  

\item The \texttt{importScene} expression is replaced with the content
  of another scene graph file.
  
\item The \texttt{template} expression declares a set of parameters
  for a following scene fragment that can later be reused like a
  macro.
 
\item Every other expression type is interpreted as a \texttt{method
    call}.

\end{itemize}

Apart from the different expression types listed above a replacement
mechanism is implemented. Every atom literal starting with a dollar
sign is interpreted as a template parameter and replaced with its
actual value.

We shall describe the semantic of the different expression types below
together with some small usage examples and a partial reference of
available node types and methods.

\subsection{File structure}

The top level structure of a ruby scene file consists of two
s-expressions. The first expression must be the header expression. It
allows the parser to confirm the file type and to get information
about the version of the used language.

The syntax of the header expression is \texttt{(RubySceneGraph <major
  Version> <minor Version>)}. Currently the only valid header states
\texttt{0} for the major and \texttt{1} for the minor version.

The header is followed by a single s-expression that contains the
scene graph body. Any further expression is discarded. The body
expression consists of an optional single template expression and a
set of node expressions. The resulting structure is outlined in
listing~\ref{rsg:structure}. Note that lines starting with a semicolon
are comment lines.

\begin{lstlisting}[caption={File Structure},label=rsg:structure]
; the header expression
(RubySceneGraph 0 1)
(
 ; the body of the file starts here

 ; declare this file as a template
 (template $lenX $lenY $lenZ $density $material)

 ; declare the top level scene graph node
 (node Box
       ; children of the top level node go here
       (node DragController
       )
 )
)
\end{lstlisting}

\subsection{Node Expression}

The scene graph consists of a tree of object instances, called nodes.
Each node in the scene graph is declared with the \texttt{(node
  <ClassName>)} expression. The \emph{ClassName} argument gives the
name of a class registered to the Zeitgeist class factory system. 

The semantic of a node expression is to instantiate a new scene graph
object of the given class type. The importer therefore relies on the
Zeitgeist class factory system to create the requested object. It is
then installed as a child of the nearest enclosing node expression. If
there is no enclosing node expression then the node is a top level
node of the expressed scene graph.

The set of top level nodes are installed as children of the node below
which the current graph is imported. This is either the global root
node of the system, or an insertion point defined with the importScene
expression within another scene graph file. The nesting of node
expressions therefore defines directly the structure of the resulting
scene graph with a very small syntactic overhead.

\subsection{Scene Graph templates}
\label{subsec:template}
The language further allows the reuse of scene graph parts in a macro
like fashion. This enables the construction of a repository of
predefined partial scenes, or complete agent descriptions. The macro
concept is available through the \texttt{(importScene <filename>
  <parameter>*)} expression. This expression recursively calls the
importer facilities of the system. It takes the nearest enclosing node
expression as the relative root node to install the scene graph
described within the given file.

Note that the given file must not necessarily be another
RubySceneGraph file but any file type registered to the importer
framework. This allows the nesting of scene graph parts expressed in
different graph description languages. An example application of this
feature is that parts of the resulting scene could be created by
application programs better suited to create 3D models. By now, we do
not exploit this feature yet.

The list of parameters given to the importScene expression is passed
on to the responsible importer plugin. If another ruby scene graph
file is imported that declares a template, they are substituted with
its formal parameters.

A template declaration within the imported file has to meet the
following syntax: \texttt{(template <parameterName>*)}. A parameter
name is a string literal that is prefixed with a dollar sign, see
listing~\ref{rsg:structure} for an example declaration. All parameter
names that follow within the body of the file are replaced with their
actual content.

The usage example in listing~\ref{rsg:import} below assumes a
\texttt{box.rsg} file. It uses that to construct boxes with varying
sizes and colors according to the template expression given in
listing~\ref{rsg:structure}.

\begin{lstlisting}[caption={importScene example}, label=rsg:import]
(RubySceneGraph 0 1)
(
 (node Transform 
       (importScene box.rsg 1 3 0.8 10 matRed)
 )
 (node Transform
       (importScene box.rsg 2 4 0.4 8 matBlue)
 )
)
\end{lstlisting}

\subsection{Method Calls}

A node created with the node expression above can further be
parameterized with method calls in order to modify its default
properties. Every expression that does not match one of the expression
types described above is interpreted as a method call. It is read as
an s-expression that starts with the name of the function, followed by
an optional list of parameters, i.e.  \texttt{(<method name>
  <parameter>*)}.

Each method call is evaluated in the context of the nearest enclosing
node expression. The semantic of a method call is to invoke the Ruby
script interface of the corresponding C++ class, hence the name of
this language.  

This design decision allowed us to rapidly implement a complete scene
description language during the development of the simulator, that is
automatically extended as new methods are exported to Ruby, our
primary scripting language. 

Implementing a completely new scene description language with its own
set of methods and property names would require the reimplementation
of functionality that was otherwise readily available from our script
interface.

An example usage is the setup of a transform node. These node types
are used to position and orient nodes along a path in the scene graph
relative to their respective parent node.  The transform node
therefore provides a method \texttt{SetLocalPos} to set the offset
relative to its parent node. Likewise a box node provides a method to
set the extents of the represented box.

\begin{lstlisting}[caption={Method call example}, label=rsg:method]
(RubySceneGraph 0 1)
(
 (node Transform 
       (setLocalPos 10 20 5)
       (node Box 
             (setExtents 1 1 1)
       )
 )
)
\end{lstlisting}

\subsection{Language Reference}

In this section we shall list the most common node types together with
their most important methods. The complete reference would be to
extensive and is a moving target as the simulator is constantly
extended.

\subsubsection{BaseNode}
The \texttt{BaseNode} type is the base class for all scene graph
nodes. The available methods are:

\begin{itemize}
\item \texttt{(importScene <string fileName>)} imports the given scene as
  described in section~\ref{subsec:template}
\item \texttt{(setName <string name>)} sets the user defined name of the
  node. This is used to reference nodes within path expressions.
\end{itemize}
\subsubsection{Transform}

The \texttt{Transform} node type positions and orients its child nodes
relative to its respective nearest parent transform node. The
available methods are available:

\begin{itemize}
\item \texttt{(setLocalPos <float x> <float y> <float z>)} defines the relative position
\item \texttt{(setLocalRotation <float x> <float y> <float z>))} defines the relative rotation in
  degrees
\item \texttt{(setLocalTransform <float m00> ... <float m33>)}
  defines the local 4x4 rotation matrix
\end{itemize}

\subsubsection{SingleMatNode}
The \texttt{SingleMatNode} is an abstract base class for all nodes
that display an object using a single material property, e.g axis,
box, sphere and capped cylinder. The following method is available:

\begin{itemize}
\item \texttt{(setMaterial <string name>)} uses the given material to draw
  the node
\end{itemize}

\subsubsection{Axis}
The \texttt{Axis} node is a SingleMatNode that displays axes of
coordinates using colored perpendicular lines. The default is to draw
lines of unit length. The following method is available:
\begin{itemize}
\item \texttt{(setSize <float size>)} sets the length of each draw axis line
\end{itemize}

\subsubsection{Box}
The \texttt{Box} node is a SingleMatNode that displays a cube with the
given extents.  The default is to draw a unit box. The following
method is available:

\begin{itemize}
\item \texttt{(setExtents <float x>) <float y> <float z>} sets the extent of
  the box along the corresponding axis.
\end{itemize}

\subsubsection{Sphere}
The \texttt{Sphere} node is a SingleMatNode that displays a sphere
with the given radius. The default is to draw a unit sphere. The
following method is available:

\begin{itemize}
\item \texttt{(setExtents <float radius>)} sets the radius of the sphere
\end{itemize}

\subsubsection{CCylinder}
The \texttt{CCylinder} node is a SingleMatNode that displays a capped
cylinder with the given radius and length. The default is to draw a
cylinder with unit length and radius. The following method is
available:

\begin{itemize}
\item \texttt{(setParams <float radius> <float length>)} sets the
  length and the radius of the capped cylinder
\end{itemize}

\subsubsection{Body}
The \texttt{Body} node represents the physical aspect of a simulated
object. The following methods are available:

\begin{itemize}
\item \texttt{(enable)} allows the body to take part in the physical
  simulation
\item \texttt{(disable)} prevents the body to take part in the
  physical simulation
\item \texttt{useGravity <bool f>)} specifies whether the body is
  influenced by gravity
\item \texttt{setSphere <float density> <float radius>)} sets the mass
  distribution of for a sphere
\item \texttt{setSphereTotal <float mass> <float radius>)} sets the
  mass distribution for a sphere
\item \texttt{setBox <float density> <float size>)} sets the
  mass distribution for a box
\item \texttt{setBoxTotal <float mass> <float size>)} sets the mass
  distribution for a box
\item \texttt{setCylinder <float density> <float radius> <float
    length>)} sets the mass distribution for a cylinder
\item \texttt{setCylinderTotal <float mass> <float radius> <float
    length>)} sets the mass distribution for a cylinder
\item \texttt{setCappedCylinder <float density> <float radius> <float
    length>)} sets the mass distribution for a capped cylinder
\item \texttt{setCappedCylinderTotal)} sets the mass distribution for
  a capped cylinder
\item \texttt{setMass <float mass>)} sets the total mass of the body
\item \texttt{setVelocity <float x> <float y> <float z>)} sets the
  initial velocity of the body
\item \texttt{setAngularVelocity <float x> <float y> <float z>)} sets
  the initial angular velocity in degrees
\end{itemize}

\subsubsection{Collider}
The \texttt{Collider} is an abstract base class for all supported
collision primitives. It further manages the set of CollisionHandler
child nodes that react to collision events detected by a Collider
instance. The available method is:

\begin{itemize}
\item \texttt{(addCollisionHandler <string ClassName>)} installs a
  collision handler node below the Collider. This i a convenience
  function that has the same effect as installing the collision
  handler using a node expression. If no collision handler is
  installed the default ContactJoint handler is installed during
  runtime.
\end{itemize}

\subsubsection{BoxCollider}
The \texttt{BoxCollider} is a Collider node that implements the box
collision primitive. The default is to create a unit sized box
collider. The available method is:

\begin{itemize}
\item \texttt{(setBoxLengths <float x> <float y> <float z>)} sets the
  extents of the collision primitive.
\end{itemize}

\subsubsection{SphereCollider}
The \texttt{SphereCollider} is a Collider node that implements the sphere
collision primitive. The default is to create a unit sized sphere
collider. The available method is:

\begin{itemize}
\item \texttt{(setRadius <float radius>} sets the radius of the
  collision primitive.
\end{itemize}

\subsubsection{CCylinderCollider}
The \texttt{CCylinderCollider} is a Collider node that implements the
capped cylinder collision primitive. The default is to create a capped
cylinder with unit length and radius. The available method is:

\begin{itemize}
\item \texttt{(setParams <float radius> <float length>)} sets the
  radius and length of the collision primitive.
\item \texttt{(setRadius <float radius>)} sets the radius of the
  collision primitive.
\item \texttt{(setLength <float length>)} sets the length of the
  collision primitive.
\end{itemize}

\subsubsection{CollisionHandler}
The \texttt{CCylinderCollider} node is an abstract base class for
handlers that take action in response to a collision. To each Collider
instance one ore more CollisionHandlers are registered. There are no
methods available in this base class.

\subsubsection{ContactJointHandler}
The \texttt{ContactJointHandler} is a CollisionHandler node that
creates an ODE contact joint between the two bodies associated with
the two affected collision primitives. Contact joints are used to
resolve a collision, i.e. to generate the appropriate force that does
not allow two bodies to interpenetrate. The available methods are
available:

\begin{itemize}
  \item \texttt{(setContactBounceMode <bool set>)}
  \item \texttt{(setContactBounceValue <float value>)}
  \item \texttt{(setMinBounceVel <float velocity>)}
  \item \texttt{(setContactSoftERPMode <bool set>)}
  \item \texttt{(setContactSoftERP <float erp>)}
  \item \texttt{(setContactSoftCFMMode <bool set>)}
  \item \texttt{(setContactSoftCFM <float cfm>)}
  \item \texttt{(setContactSlipMode <bool set>)}
  \item \texttt{(setContactSlip <float slip>)}
  \item \texttt{(setContactMu <float mu>)}
\end{itemize}

All methods above enable and set the corresponding value of the ODE
contact structure. Please refer to the ODE user guide~\cite{Smi04} for
details.

\subsubsection{RecorderHandler}

The \texttt{RecorderHandler} is a CollisionHandler that accumulates
collision information of the Collider it belongs to. It aids for
example in the implementation of bumper sensors or in the
implementation of game rules. There it is used to detect if agents are
in certain areas of the playing field. These areas are for example
expressed as box colliders. No methods further are available through
the script interface.

\subsubsection{Joint}

The \texttt{Joint} node is an abstract base class for all joints.  It
defines a relationship (a constraint) that is enforced between two
bodies so that they can only have certain positions and orientations
relative to each other.

Note that the joint geometry parameter setting functions should only
be called after the joint has been attached to bodies, and those
bodies have been correctly positioned, otherwise the joint may not be
initialized correctly. If the joint is not already attached, these
functions will do nothing. 

Note that joint nodes are positioned and orientated according to the
parent transform nodes. The available methods are:

\begin{itemize}
\item \texttt{attach(<string path1> <string path2>)} attaches the
  joint to some new bodies. If the joint is already attached, it will
  be detached from the old bodies first. To attach this joint to only
  one body, omit the second path parameter.  This effectively attaches
  the body to the static environment.  
  
  The path expression follow the common Unix syntax and are relative
  to the joint node. Object instances are referred by the name set
  using the SetName function, using \texttt{"/"} as the path separator
  and \texttt{".."} to refer to the parent node.

\begin{itemize}
  \item \texttt{(setAnchor <float x> <float y> <float z>)} sets the
    anchor point in local coordinates relative to the joint node.
\end{itemize}

\item \texttt{setHighStopDeg)}
\item \texttt{(setLowStopDeg)}
\item \texttt{(setHighStopPos)}
\item \texttt{(setLowStopPos)}
\item \texttt{(setBounce)}
\item \texttt{(setCFM)}
\item \texttt{(setStopCFM)}
\item \texttt{(setStopERP)}
\item \texttt{(setSuspensionERP)}
\item \texttt{(setSuspensionCFM)}
\item \texttt{(setLinearMotorVelocity)}
\item \texttt{(setAngularMotorVelocity)}
\item \texttt{(setMaxMotorForce)}

\end{itemize}

The last block of methods above set the corresponding values of the
ODE joint structure. Please refer to the ODE user guide~\cite{Smi04}
for details.

\subsubsection{FixedJoint}

The \texttt{FixedJoint} node represents a joint that maintains a fixed
relative position and orientation between two bodies, or between a
body and the static environment. 

\subsubsection{BallJoint}

The \texttt{BallJoint} node represents a \emph{ball and socket joint}
connects two bodies at an anchor point. It enforces a constant
distance of the two bodies to this anchor. Further it keeps a constant
facing of each body towards the anchor point. The two bodies can
otherwise rotate freely around the anchor point.

\subsubsection{HingeJoint}

The \texttt{HingeJoint} node represents a \emph{hinge joint}. This
joint type connects two rigid bodies along a single axis that passes
through a defined anchor point. The axis is fixed to the z axis in the
local coordinate system of the node. This can be adjusted using a
parent transform node. Like the ball and socket joint it enforces a
constant distance and facing with respect to the anchor point. The
rotational freedom is however restricted to the defined axis.

\subsubsection{Hinge2Joint}

The \texttt{Hinge2Joint} node represents a \emph{two-hinge joint}. It
acts like two hinge joints connected in series.  Each hinge joint
defines a different hinge axis but shares the same anchor point. The
two axis are fixed to the x and z axis in the local coordinate system
of the node. This can be adjusted using a parent transform node. This
joint type is commonly used to simulate the steering wheel of a car.
In this case the first axis allows the steering of the wheel and the
second axis allows the wheel to rotate.

\subsubsection{UniversalJoint}

The \texttt{UniversalJoint} node represents a so called
\emph{universal joint}. It acts like a ball and socket joint that
constrains an extra degree of rotational freedom. The universal joint
works on two perpendicular axes, one defined on each body. These axes,
fixed to the x and z axes in the local coordinate system of the joint
are forced to stay perpendicular. This means that the rotation of the
two bodies about the axis perpendicular to the two other axes will be
equal. So, if any of the two bodies turns around the axis, the other
will turn as well.

% TODO angular motor, body controller, drag controller

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual"
%%% End: 
