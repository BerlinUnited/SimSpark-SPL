\section{Soccer Simulation}

\subsection{Soccer Team}

Your soccer team consists of a number of robots with equal
capabilities. The programs you should write to create a team exchange
data with the (virtual) low level control system delivered with the
robots. Both perceptors and effectors of your robots work with
S-expressions, this is the syntax you know already from the 2D soccer
simulator, or maybe also from your favorite programming language :).

\subsection{Environment}

Some technical data of the environment and of your new robots:

The playing field is a plane with FIFA standard soccer field size
(length between 100m and 110m, width between 64m and 75m).  Goal boxes
and the ball are also standard FIFA size: goals are 7.32m wide; the
ball has got a diameter of 0.222m and weighs between 0.41kg and
0.45kg.  Because our agents are small and cannot jump, goals are only
0.5m high -- the official FIFA height is 2.44m.

FIFA does not say too much about gravity (probably because they can't
change it anyway), but in our simulation, gravity is fixed to
9.81m/$s$.

Simulator steps are 0.01 seconds long. Connected monitors receive an
update every 15th simulator step.

Many of the values contained in this text are subject to change and it
is likely that this text does not always reflect the current state of
affairs. You'll find the current set of constants in the setup script
that the server executes at startup, please see
\texttt{./app/simulator/rcssserver3D.rb}. After the first run of the
server this file is copied to a directory under your home directory,
called \texttt{~/.rcssserver3d} and is read back from there on
subsequent runs. Any experimental changes should happen there.

\subsection{Players}

In the current version of the simulator, robots are represented as
spheres (until we can come up with a more sophisticated representation
next year). The diameter of all robots is 0.44m, and each robots
weighs 75kg.

Robots possess a kind of omnidrive, which adds some physical force to
the robot body. By using the omnidrive, it is possible to accelerate
into any direction, and it is also possible to jump very little.
However, the omnidrive does only work if the robot is actually
touching the soccer field. If you stop accelerating, robots will still
move for a while, and you also cannot suddenly stop when moving with
full speed (but you can use it for breaking). The maximum speed and
the maximum height for jumping up if yet to be discovered.

When a player initially connects to the server you have to do two
thing in order to get started. At first you must create the robot type
you want to use during the game. Currently we are limited to the robot
sphere described above. In later versions more sophisticated robot
models may be available. It is the job of the create effector to
select and create one robot type at startup. Further the player must
receive a number and join a team. This is the job of the init
effector.

\subsubsection{Create effector}

When you initially connect to the simulator, your agent does not have
any physical representation. The only thing your agent has got is a
"CreatEeffector". The idea of the CreatEeffector is that you can
request different effectors, perceptors or robot types. Currently,
there is only one fixed robot type, so the CreateEffector ignores all
parameters. For now, you should simply do "(create)" at the beginning
and you will get the default robot type.

Example command: \texttt{(create)}

\subsubsection{Init Effector}

To set the team name and uniform number, you have to use the
InitEffector. Prior to initializing, your effectors and perceptors
will not work properly.  

Syntax: \texttt{(init (unum <number>) (teamname <string>))}

Example: \texttt{(init (unum 7) (teamname RoboLog))}

\subsubsection{Beam Effector}

Similar to the kickeffector, the initial plan was not to introduce any
artificial actions like "beaming" agents from one place to another
place, similar to the "move" command in 2d soccer server. Still, the
plan is to develop the soccer simulation so that beaming can disappear
from the set of effectors.

However the problem was that due to limited time we had to do
something about moving agents to their half in before kick off mode.
To remove "beaming", the referee has to be extended to send yellow or
red cards to players that don't behave properly... with your help :)
we are going to work on this feature in the near future. Until then,
beaming of agents is allowed in \texttt{beforekickoff} mode.

The beam effector expects three coordinates, but currently forces the
third component to be zero, i.e. agents are only allow to move on the
ground along the horizontal plane.

Syntax: \texttt{(beam <x> <y> <z>)}

Example: \texttt{(beam  -6.6 0 0)}

\subsubsection{Drive Effector}

To use the omnidrive of the agent, you have to use the so called
"DriveEffector", which takes a cartesian vector (x y z) with a maximum
length of 100 units. The x-coordinate points towards the opponents
team side of the field, z points up. With the DriveEffector, you set a
kind of motor force, i.e. if you want to drive full speed for a while,
it is sufficient to use the DriveEffector *once*. The force you set is
applied at each simulator step until you change it again. The
DriveEffector works reliable, there is a small error for forces along
each axis (each up to 2\% of the applied force). The error is normally
distributed around 0.0.

Using the omnidrive consumes battery. You get to know of battery
states by reading the AgentStatePerceptor. If the battery is empty,
the omnidrive will stop working. It is also possible to push away
other robots. Using this feature to push away opponents is discouraged
:).

Syntax: \texttt{(drive <x> <y> <z>)}

Example command: \texttt{(drive 20.0 50.0 0.0)}

\subsubsection{Kick Effector}

To move the ball, you have the option of simply using the robots to
push the ball into a desired direction, or you can use the
kickeffector to kick the ball. Originally, we did not intend to create
an artificial kickeffector. However, to make use of the 3rd dimension,
this was the easiest way. It is intended to remove this kind of kick
effector in future versions (not this years' competition) in favor of
a real physical device.

The kickeffector can accelerate the ball radially away from the robot
body. The kickeffector takes an angle as first argument. This is the
latitudal angle (in degrees) for accelerating the ball. It is
restricted to a number between 0 and 50. The second argument indicates
the kicking power and this is a number between 0 and 100. It is
interpreted as the percentile of the maximum available power. The
kickeffector adds a force and a torque to the ball. This happens over
a fixed number of simulation steps. Currently 10 cycles are used. This
corresponds to 1/10s simulation time. To kick the ball, the ball has
to be very close to the robot, i.e. it has to be within the so called
kickable margin of the player. Currently 0.04m are configured.

You cannot change the kicking angle in the horizontal plane. This
means that you have to move the robot so that it can kick into the
desired direction. Right now, the kickeffector is not very strong,
because something like an offside rule is missing. It should also not
be possible to move other robots by kicking the ball against them
anymore. (at least not very much :) Like the DriveEffector, the
kickeffector does only work if the robot touches the soccer field.

The kickeffector noise has the following parameters: 

\begin{itemize}
  
\item The angle error in the x-y plane is quite low and normally
  distributed around 0.0 with sigma = 0.02. The

\item The latitudal angle error is normally distributed around 0.0.
  This angle error is low with sigma = 0.9 at both extreme positions,
  i.e. 0 and at 50 degrees. Towards the middle of the range the angle
  error gets higher with sigma up to 4.5.
  
\item The kick power error is normally distributed around 0.0 with
  sigma = 0.4

\end{itemize}

Syntax: \texttt{(kick <angle> <power>)}

Example command: \texttt{(kick 20.0 80.0)}

\subsubsection{Vision Perceptor}

Your robots possess a special omnicam with some smart image processing
software attached :). Robots have a 360 degrees view. The
VisionPerceptor delivers lists of seen objects, where objects are
either others robots, the ball, or markers on the field. Currently
there are 8 markers on the field: one at each corner point of the
field and one at each goal post.

With each sensed object you get:

\begin{itemize}
  
\item The distance between the player and the object.
  
\item The angle in the horizontal plane. Zero degree always points to
  the opponent goal.

\item The latitudal angle. Here zero degree means horizontal.

\end{itemize}
  
Contrary to 2D soccer simulation, the vision system does not deliver
object velocities. Objects can be occluded by other objects (this is
not completely implemented yet). All distances and angles are given
relative to the camera position. The camera is currently located at
the center of the robot sphere.

The noise parameters of the vision system are as follows:

\begin{itemize}
  
\item A small calibration error is added to the camera position. For
  each axis, the error is uniformly distributed between -0.005m and
  0.005m. The error is calculated once and remains constant during the
  complete match.

\item Dynamic noise normally distributed around 0.0
  \begin{itemize}
    \item distance error:  sigma = 0.0965
    \item angle error (x-y plane): sigma = 0.1225
    \item  angle error (latitudal): sigma = 0.1480
    \end{itemize}
\end{itemize}

Syntax: 
\begin{verbatim}
(Vision 
        (<Type> 
        (team <teamname>) 
        (id <id>) 
        (pol <distance> <horizontal angle> <latitudal angle>)
        )
)
\end{verbatim}

Possible values are as follows:

\begin{itemize}

\item 'Flag' with \texttt{<id>} one of '\texttt{1\_l}', '\texttt{2\_l}', '\texttt{1\_r}', '\texttt{2\_r}'
\item 'Goal' with \texttt{<id>} one of '\texttt{1\_l}', \texttt{'2\_l}', '\texttt{2\_l}', '\texttt{2\_r}'
\item 'Player' with \texttt{<id>} being the uniform number of the player

\end{itemize}

Example Vision output: 

\begin{verbatim}
(Vision (Flag (id 1_l) (pol 54.3137 -148.083 -0.152227)) (Flag (id
2_l) (pol 59.4273 141.046 -0.131907)) (Flag (id 1_r) (pol 61.9718
-27.4136 -0.123048)) (Flag (id 2_r) (pol 66.4986 34.3644 -0.108964))
(Goal (id 1_l) (pol 46.1688 179.18 -0.193898)) (Goal (id 2_l) (pol
46.8624 170.182 -0.189786)) (Goal (id 1_r) (pol 54.9749 0.874504
-0.149385)) (Goal (id 2_r) (pol 55.5585 8.45381 -0.146933)) (Ball (pol
6.2928 45.0858 -0.94987)) (Player (team robolog) (id 1) (pol 7.33643
37.5782 5.86774)))
\end{verbatim}

\subsubsection{Say Effector}

To broadcast messages to other players, you have to use the
SayEffector. Messages can be \texttt{sayMsgSize} (for now 512)
characters long, where valid characters for say messages are the
printing characters* except space and (). Messages players say can be
heard within a distance of \texttt{audioCutDist} meters (for now 50)
by members of both teams. The use of the SayEffector is only
restricted by the limited capacity of the players of hearing messages.
See the Hear Perceptor section for a list of server variables
affecting these capacities.

* In the seven-bit ASCII character set, the printing characters are
0x20 to 0x7E.

Syntax: 
\begin{verbatim}
(say <message>)
\end{verbatim}

Example command:
\begin{verbatim}
(say player10_Pass)
\end{verbatim}

\subsubsection{Hear Perceptor}

You get percepts from this perceptor when a player uses SayEffector
and sends a message. The format of the aural sensor message from the
is:

\begin{verbatim}
(hear <time> <direction in degree> <message>)
\end{verbatim}

\texttt{<time>} indicates the current time.

\texttt{<direction in degree>} is relative direction to sender
(without noise) if it is another player, otherwise it is
\texttt{"self"} (without quotation mark).

\texttt{<message>} is the message. The maximum length is
\texttt{sayMsgSize} bytes.

The server parameters that affect the Hear perceptor are:


\begin{itemize}
\item \texttt{audioCutDist}, default 50.0
\item \texttt{hearMax}, default 2
\item \texttt{hearInc}, default 1
\item \texttt{hearDecay}, default 2
\item \texttt{sayMsgSize}, default 512
\end{itemize}

A player can only hear a message if the player's hear capacity is at
least \texttt{hearDecay}, since the hear capacity of the player is
decreased by that number when a message is heard. Every cycle the hear
capacity is increased with \texttt{hearInc}. The maximum hear capacity
is \texttt{hearMax}. To avoid a team from making the other team's
communication useless by overloading the channel the players have
separate hear capacities for each team. With the current values this
means that a player can hear at most one message from each team every
second perceptor update.

If more messages arrive at the same time than the player can hear the
messages actually heard are undefined (The current implementation
choose the messages according to the order of arrival). This rule does
not include messages from oneself. In other words, a player can hear a
message from himself and hear a message from another player in the
same perceptor output.

A message said by a player is transmitted only to players within
\texttt{audioCutDist} meters from that player. For example, a
defender, who may be near his own goal, can hear a message from his
goal-keeper but a striker who is near the opponent goal can not hear
the message.

Example Hear output:
\begin{verbatim}
(hear 0.8 -179.99 Test_1)
(hear 0.4 self Test_2)
\end{verbatim}

\subsubsection{GameStatePerceptor}

The GameStatePerceptor tells you about the current status of the game.
The first percept you get from this perceptor tells you about some of
the game variables, like ball weight and field size additionally.

Syntax: \texttt{(GameState (<Name> <Value>) ...)}

Possible values for \texttt{<Name>} are:

\begin{itemize}
  
\item \texttt{time} gives the current simulation time (as a float
  value) passed in seconds
  
\item \texttt{playmode} gives the current playmode as a string.
  Possible playmodes are \texttt{BeforeKickOff},
  \texttt{KickOff\_Left}, \texttt{ickOff\_Right}, \texttt{PlayOn},
  \texttt{KickIn\_Left}, \texttt{KickIn\_Right},
  \texttt{corner\_kick\_left}, \texttt{corner\_kick\_right},
  \texttt{goal\_kick\_left}, \texttt{goal\_kick\_right},
  \texttt{offside\_left}, \texttt{offside\_right}, \texttt{GameOver},
  \texttt{Goal\_Left}, \texttt{Goal\_Right}, \texttt{free\_kick\_left},
  \texttt{free\_kick\_right}, \texttt{unknown}.
\end{itemize}

For an up to day list of all playmodes refer to
\texttt{./plugin/soccer/soccertypes.h}


Example GameState output:

\texttt{(GameState (time 0) (playmode BeforeKickOff))}

\subsubsection{AgentState perceptor}

The AgentStatePerecptor tells you about the current state of your
agent, currently its battery level and temperature.

Syntax:
\begin{verbatim}
(AgentState
        (battery <battery level in percent>)
        (temp <temperature in degree>)
)
\end{verbatim}

Example AgentState output:
\texttt{(AgentState (battery 100) (temp 23))}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual"
%%% TeX-master: t
%%% End: 




