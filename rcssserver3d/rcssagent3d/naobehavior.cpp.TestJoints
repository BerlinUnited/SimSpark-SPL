/* -*- mode: c++; c-basic-offset: 4; indent-tabs-mode: nil -*-
   this file is part of rcssserver3D
   Thu Nov 8 2005
   Copyright (C) 2005 Koblenz University

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; version 2 of the License.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
*/
#include "naobehavior.h"
#include <iostream>
#include <sstream>
#include <cmath>

using namespace oxygen;
using namespace zeitgeist;
using namespace std;
using namespace boost;
using namespace salt;

const double PI = 3.1415926;

NaoBehavior::NaoBehavior() : mZG("." PACKAGE_NAME), mInit(false)
{
}

void NaoBehavior::SetupJointIDMap()
{
    mJointIDMap.clear();
    mJointIDMap["hj1"]      = JID_HEAD_1;
    mJointIDMap["hj2"]      = JID_HEAD_2;

    mJointIDMap["llj1"]     = JID_LLEG_1;
    mJointIDMap["rlj1"]     = JID_RLEG_1;
    mJointIDMap["llj2"]     = JID_LLEG_2;
    mJointIDMap["rlj2"]     = JID_RLEG_2;
    mJointIDMap["llj3"]     = JID_LLEG_3;
    mJointIDMap["rlj3"]     = JID_RLEG_3;
    mJointIDMap["llj4"]     = JID_LLEG_4;
    mJointIDMap["rlj4"]     = JID_RLEG_4;
    mJointIDMap["llj5"]     = JID_LLEG_5;
    mJointIDMap["rlj5"]     = JID_RLEG_5;
    mJointIDMap["llj6"]     = JID_LLEG_6;
    mJointIDMap["rlj6"]     = JID_RLEG_6;

    mJointIDMap["laj1"]     = JID_LARM_1;
    mJointIDMap["raj1"]     = JID_RARM_1;
    mJointIDMap["laj2"]     = JID_LARM_2;
    mJointIDMap["raj2"]     = JID_RARM_2;
    mJointIDMap["laj3"]     = JID_LARM_3;
    mJointIDMap["raj3"]     = JID_RARM_3;
    mJointIDMap["laj4"]     = JID_LARM_4;
    mJointIDMap["raj4"]     = JID_RARM_4;
}

std::string gJointEff_2_Str[] = 
{
"he1",
"he2",
"lle1",
"rle1",
"lle2",
"rle2",
"lle3",
"rle3",
"lle4",
"rle4",
"lle5",
"rle5",
"lle6",
"rle6",
"lae1",
"rae1",
"lae2",
"rae2",
"lae3",
"rae3",
"lae4",
"rae4",
};

string NaoBehavior::Init()
{
    mZG.GetCore()->ImportBundle("sexpparser");

    mParser = shared_static_cast<BaseParser>
        (mZG.GetCore()->New("SexpParser"));

    if (mParser.get() == 0)
    {
        cerr << "unable to create SexpParser instance." << endl;
    }

    SetupJointIDMap();
    // use the scene effector to build the agent and beam to a
    // position near the center of the playing field
    return
        "(scene rsg/agent/nao/nao.rsg)";
}

void NaoBehavior::ParseHingeJointInfo(const oxygen::Predicate& predicate)
{
    //cout << "(NaoBehavior) parsing HJ info" << endl;

    // read the object name
    string name;
    Predicate::Iterator iter(predicate);

    if (! predicate.GetValue(iter, "n", name))
    {
        return;
    }

    // try to lookup the joint id
    TJointIDMap::iterator idIter = mJointIDMap.find(name);
    if (idIter == mJointIDMap.end())
    {
        cerr << "(NaoBehavior) unknown joint id!" << endl;
        return;
    }

    JointID jid = (*idIter).second;

    // read the angle value
    HingeJointSense sense;
    if (! predicate.GetValue(iter,"ax", sense.angle))
    {
        return;
    }

    // update the map
    mHingeJointSenseMap[jid] = sense;
}

void NaoBehavior::ParseUniversalJointInfo(const oxygen::Predicate& predicate)
{
    // read the object name
    string name;
    Predicate::Iterator iter(predicate);

    if (! predicate.GetValue(iter, "n", name))
    {
        return;
    }

    // try to lookup the joint id
    TJointIDMap::iterator idIter = mJointIDMap.find(name);
    if (idIter == mJointIDMap.end())
    {
        cerr << "(NaoBehavior) unknown joint id!" << endl;
        return;
    }

    JointID jid = (*idIter).second;

    // record the angle and rate values
    UniversalJointSense sense;

    // try to read axis1 angle
    if (! predicate.GetValue(iter,"ax1", sense.angle1))
    {
        cerr << "(NaoBehavior) could not parse universal joint angle1!" << endl;
        return;
    }
    // try to read axis2 angle
    if (! predicate.GetValue(iter,"ax2", sense.angle2))
    {
        cerr << "(NaoBehavior) could not parse universal joint angle2!" << endl;
        return;
    }   
    // try to read axis2 rate

    // update the map
    mUniversalJointSenseMap[jid] = sense;
}


// This is just a demo implementation. Message is printed and discarded

void NaoBehavior::ParseHearInfo(const oxygen::Predicate& predicate)
{
    double heartime;
    string sender;
    string message;
    
    Predicate::Iterator iter(predicate);

    if (! predicate.AdvanceValue(iter, heartime))
    {
        cerr << "could not get hear time \n";
        return;
    }

    
    if (! predicate.AdvanceValue(iter, sender))
    {
        cerr << "could not get sender \n";
        return;
    }


    if (! predicate.GetValue(iter, message))
    {
        cerr << "could not get message \n";
        return;
    }

    if (sender == "self")
    {
        cout << "I said " << message << " at " << heartime << endl;

    } else {
        cout << "Someone "
             << (abs(atof(sender.c_str()))<90?"in front of":"behind")
             << " me said " << message << " at " << heartime << endl;
    }
    return;
    
}


static bool is_use_my_speed = false;
static double my_speed = 0;
static bool is_achieved = false;

void NaoBehavior::InitTestJoint()
{
    mJointState = 0;
    mCounter    = 0;
    
    is_use_my_speed = false;
    my_speed = 0;
    is_achieved = false;
}
 
void GetCommand(stringstream &ss, bool is_first, const string &eff, double speed)
{
    if (is_first) ss << "(" << eff << " " << speed << " 0)"; 
    else ss << "(" << eff << " 0 " << speed << ")"; 
}

bool NaoBehavior::TestJoint(stringstream &ss, JointID jid, double abs_speed, bool is_first)
{
    mCounter++;
    int max_need_cycles = (int)(2 * PI / abs_speed / 0.02);
    string eff = gJointEff_2_Str[jid]; 

    double angle = GetJointAngle(jid, is_first);
    std::cout << "==========================================\n";
    std::cout << "Joint eff name:" << eff << "\tCurrent " << (is_first?"":"second ") << " angle: " << angle << "\n";
    std::cout << "The: " << mCounter << " cycle.\t\tWill do :" << max_need_cycles << " cycles.\n";

    switch (mJointState)
    {
        case 0:
            if (mCounter > max_need_cycles) { mCounter = 0; mJointState++; return false; }
            std::cout << "Go to the min angle now.\n";
            GetCommand(ss, is_first, eff, -abs_speed);         
 	    break;

        case 1: 
            if (mCounter > max_need_cycles) { mCounter = 0; mJointState++; return false; }
            std::cout << "Go to the max angle now.\n";
            GetCommand(ss, is_first, eff, abs_speed);         
 	    break;

        case 2:           
            if (fabs(angle) < 0.01)
            {
                 is_achieved = true;
            }

            if (is_achieved && mCounter > max_need_cycles) return true;

            
            std::cout << "Go to the origin zero angle now.\n";
            if (angle - abs_speed * 0.04 < 0)
            {
                is_use_my_speed = true; 
                my_speed = -0.1;
            }

            GetCommand(ss, is_first, eff, is_achieved ? 0 : (is_use_my_speed ? my_speed : -abs_speed));         
 	    break;
        
        default:
            break;
    }
    return false;
}
 

double NaoBehavior::GetJointAngle(JointID jid, bool is_first)
{
    double deg = 0;
    //if (jid == JID_LLEG_1_2 || jid == JID_RLEG_1_2)
    //{
    //    if (is_first) deg = mUniversalJointSenseMap[jid].angle1;
    //    else deg = mUniversalJointSenseMap[jid].angle2;
    // }
    //else 
    deg = mHingeJointSenseMap[jid].angle;
   
    return deg * PI / 180.0;
}


string NaoBehavior::Think(const std::string& message)
{
    if (! mInit)
    {
        mInit = true;
        return "(init (unum 0)(teamname NaoRobot))";
    }

    // parse message and extract joint angles
    shared_ptr<PredicateList> predList = mParser->Parse(message);

    if (predList.get() != 0)
    {
        PredicateList& list = *predList;

        for (PredicateList::TList::const_iterator iter = list.begin();
             iter != list.end();
             ++iter)
        {
            const Predicate& predicate = (*iter);

            switch(predicate.name[0])
            { 
            case 'H': // hinge joint (HJ)
                ParseHingeJointInfo(predicate);
                break;

            case 'U': // universal joint (UJ)
                ParseUniversalJointInfo(predicate);
                break;

            case 'h': // hear
                ParseHearInfo(predicate);
                break;

            default:
                break;
            }
        }
    }

    
 	{
		stringstream ss;
		static int xx = 0;
		++xx;
                //if (xx < 100) { ss << "(lae1 13)" << "(rae1 13)"; }
                //else if (xx < 200) { ss << "(lae1 -13)" << "(rae1 -13)"; }
 
                if (xx < 100) { ss << "(lle5 23)" << "(rle5 23)"; }
                else if (xx < 200) { ss << "(lle5 -23)" << "(rle5 -23)"; }

                else { xx = 0; }
 
 		std::cout << xx << ": " << ss.str() << "\n";
                return ss.str();
	}
       
    static bool is_init  = false;
    static bool is_first_joint = true;
    static JointID test_joint_id = JID_LARM_1;  //JID_HEAD_1;

    if (! is_init) 
    {
        InitTestJoint();
        is_init = true;
    }

    stringstream ss;
    double abs_speed = 3;

    if (TestJoint(ss, test_joint_id, abs_speed, is_first_joint))
    {
        //This joint has finished, move to the next
        is_init = false;
        
        //if (test_joint_id == JID_LLEG_1_2 || test_joint_id == JID_RLEG_1_2)
        //{ 
        //    if (is_first_joint) is_first_joint = false;
        //}
        //else 
        {
            const int SUM_JOINT = JID_RARM_4 + 1;
            test_joint_id = (JointID)((test_joint_id + 1));//SUM_JOINT); 
        }
    }

    std::cout << "Sent Cmd: " << ss.str() << "\n";
    return ss.str();
}
